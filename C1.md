###关系运算子集定义
####基础关系运算介绍
　　本文所讨论的关系运算限定为关系代数中定义的原始运算和域计算运算。而刚刚所指的关系代数不是Augustus De Morgan于1860年为代数逻辑提供的关系代数，而是计算机科学中一般所指的一阶逻辑分支，即闭合与运算下的关系的集合。而关系运算的本质就是其作用于一个或多个关系上来生成另一个关系。

　　在1970年E.F. Codd发表数据的关系模型之后，关系代数被广泛地用来设计和定义数据库查询语言或语言规范。由于我们只是希望利用其在数据库查询语言中的指导性作用来定义一组具有广泛适用性并且正确合理的关系运算子集，从而定义我们需要的ORM子集，所以本文中我们并不关心关系代数的系统论证，将更多地去利用基础的关系代数定义去证明我们选取的运算子集能适用于一般的企业级开发，并在用所含运算模拟未包含运算时进行优化设计。

　　关系代数中定义的原始运算定义并不唯一。因为对于任何代数而言，一些运算是原始的，另一些运算则可以通过原始运算来定义。而这些运算的选取，除了需要符合常人的思维习惯之外，某种程度上来说是随机的。 Codd对他的代数原始运算做出的选取为“选择”、“投影”、“笛卡尔积”、“并集”、“差集”和“重命名”。在此基础上，我们根据一般SQL操作定义的情况，添加“除法”运算，并将这7个运算分为两类：

* 传统集合运算：并集，差集（交集可用差集定义）；
* 关系专用运算：选择，投影，笛卡尔积，重命名，除法。

　　而根据我们实际的设计需要，我们又将所有这7个运算按操作对象集合分为一元关系运算与多元关系运算两类：

* 一元关系运算：选择，投影，重命名；
* 多元关系运算：并集，差集，笛卡尔积。

　　本章中，我们将对这七类原始运算进行分析，并根据我们对TORM的需求来取舍，并定义我们需要的运算子集。

####一元关系运算（单表）集合定义
#####投影
######定义
　　投影是写为 $$$ \pi_{a_1,...,a_n}(R) $$$的一元运算，这里$$$ a_1,...,a_n $$$是属性名字集合。这种投影的结果为当前所有在$$$R$$$中的元组被限制为$$$ \\{a_1,...,a_n\\} $$$的时候所获得的集合。

######分析
　　根据定义，投影可以简单理解为数据库中对表字段的选取，而这是所有非聚集查询运算中必然包含的操作之一，这些都分装在已经定义的SQL当中，不再需要我们处理。而当进行ORM时，我们也需要根据我们对象实体的属性在数据库表字段的基础上再进行一次投影，使得DMO中仅包含实体所需要的属性值。

######结论
　　投影运算作为关系运算的必要原始运算，将在我们的关系运算子集中定义，但我们不会在系统中实现它，因为他已经被SQL本身完整地实现了。

#####选择
######定义
　　广义选择是写为$$$ \sigma_\varphi(R) $$$的一元运算，这里的$$$ \varphi $$$是由正常选择中所允许的原子和逻辑算子$$$ \bigwedge $$$（与）、$$$ \bigvee $$$(或)和$$$ \lnot $$$（非）构成的命题公式。这种选择选出R中使$$$ \varphi $$$成立的所有元组。

######分析
　　选择运算是所有数据库查询操作的基础。从定义中可以看出，在关系代数中选择运算只包含逻辑谓词谓词，而实际数据库操作中可能会包含一些业务需要的非逻辑谓词。这也是因为关系代数与实际数据库在查询结果上有本质的区别：关系代数的关系运算结果为集合，集合为无序的；实际数据库中的操作结果为数据序列，这些序列或显式或隐式地包含了一定的有序关系。

######结论
　　考虑到实现的复杂度，在我们的关系运算子集定义中，不定义非逻辑谓词的选择操作（也无法定义）。非逻辑谓词的选择操作我们则会通过数据库访问层插件或为查询结果对象添加AOP切面来实现。

#####重命名
######定义
　　重命名是写为$$$ \rho_{a / b}(R) $$$的一元运算，这里的结果同一于$$$R$$$，除了在所有元组中的$$$b$$$字段被重命名为$$$a$$$字段之外。它被简单的用来重命名关系的属性或关系自身。

######分析
　　重命名在Codd提出他定义的关系代数原始运算时被忽略了，而实际上在对不同的关系进行运算时，关系间的重名属性会导致运算的定义存在二义性，所以重命名在ISBL提出时被显著地包括了。同样，在实际数据库中在进行数据库操作时，为了避免表属性同名的问题，也会使用重命名操作。不过我们在进行ORM时，操作的表空间对象限定为与应用一一对应，而同一个表空间中不会有同名表，所以只需采用加上了表名的字段全路径就可以区别。

　　但实际上，关系属性其实没有关系的特征，换句话说关系属性本身和关系之间的关联是松散的，那也就意味着在数据库操作中的字段全路径其实本身也是经过了默认的重命名运算。所以我们在ORM时对DMO属性和数据库字段的映射其实也是为其做了一次重命名运算。

######结论
　　重命名运算也是关系运算的必要原始运算，将在我们的关系运算子集中定义，我们将在系统中提供其默认的实现，更复杂的重命名运算将作为扩展另作实现。

####多元关系运算分析及在该场景下的处理方式
　　TORM主要是针对企业级开发在单关系（单表）处理时的操作简化，并不需要对多元关系运算提供完整地支持。虽然在现有的ORM框架中，多元关系操作一直饱受诟病，但TORM作为一个标准ORM框架，并考虑到其今后的扩展性，我们需要在定义其关系运算集合时考虑到多元操作。即使我们目前的实现并不以一定要包含这些运算，但我们需要保证，在一个可切入的扩展层面上TORM对多元操作而言是具有良好扩展性的。

#####多元运算的应用场景分析

######笛卡尔积
　　关系代数中的笛卡尔积定义与集合论有所不同，这里的元组是平坦的、无子元组的（可参考1NF的定义）。集合论中$$$n$$$元组与$$$m$$$元组的笛卡尔积是$$$2$$$元组，而关系代数中他们的笛卡尔积把这个$$$2$$$元组平展为$$$n+m$$$元组。形式上，$$$R \times S$$$被定义为:
$$
R \times S = \\{r \cup s| r \in R, s \in S\\}
$$
　　而在关系代数中，我们一般不会使用到原始的笛卡尔积运算，因为如上式定义的笛卡尔积运算中两个关系不能有公共属性，那这样的运算结果对业务而言是没有意义的。绝大多数的场景下，我们会选择具有至少一个公共属性的两个关系进行运算，而这就是我们一般所说的连接（join），记为$$$\bowtie$$$。

　　在关系代数中，连接还有一种特殊形式。设$$$\theta$$$是在集合$$$ $$$中的二元关系，$$$\\{a,b\\}$$$是关系属性，$$$v$$$是常量，当连接$$$R \bowtie S$$$满足逻辑谓词$$$a \theta b $$$或$$$a \theta v$$$时，我们称这种连接为$$$\theta -$$$连接，写为$$$R {\overset{\bowtie}{\_ {a \theta b}}} S$$$或$$$R {\overset{\bowtie}{\_ {a \theta v}}} S$$$。但在实际数据库中并不需要也往往没有定义$$$\theta -$$$连接，因为我们可以通过将连接退化为笛卡尔积再进行用等价谓词进行选择来模拟$$$\theta -$$$连接，记为：
$$
R \bowtie _\theta S = \sigma _ \theta (R \times S)
$$

　　除此之外，我们将连接按照算子运算对象所指关系的属性投影方式，可将其分为连接（内连接）与外链两类，出去刚刚所说的自然连接，其中包含:

* 半连接:分为左内连$$$R \ltimes S $$$和右内连$$$ R\rtimes S$$$。半连接的结果只是在$$$S$$$中有在公共属性名字上相等的元组所有的$$$R$$$中的元组。其形式定义如：$$$R \ltimes S = \\{ t : t \in R, s \in S, fun (t \cup s) \\}$$$。* 半连接可被自然连接模拟，取$$$a1,...,an$$$是$$$R$$$的属性名，则有$$$R \ltimes S = \prod _ {a1,..,an}（R\bowtie S）$$$。
* 反连接:反连接记为$$$ R \triangleright S $$$。反连接的结果是在$$$S$$$中没有在公共属性名字上相等的元组的$$$R$$$中的那些元组。反连接还可以定义为半连接的补集:$$$R \triangleright S=R-R \ltimes S$$$,所以半连接也可以被自然连接加投影模拟。
* 外连接:外连接包括左外连、右外连、全外连，它们是由内连接结果元组加上通过向一个操作数的未匹配元组扩展上另一个操作数的每个属性的“填充”值而形成的元组组成。根据外连接的定义，它也可以通过自然连接加投影进行模拟。
######并差集
#####一次多元运算和多次一元运算的等价关系
#####多元运算和与其等价的一元运算的实际时空复杂度分析
#####是否将多元运算加入集合的分析
基础集合不加入多元运算
简单多元运算预留扩展并设计扩展模式
#####小结
$$
R \bowtie _ \theta S=\\{r \cup s:r \in R,s \in S,f _ \theta(t \cup s)\\}
$$
$$
\sigma _ \phi( _ {\sigma _ {\phi_1}(R) \times \sigma _ {\phi_2}(S)})=\\{r \cup s:r \in R,s \in S,f _ \phi(t,s) \cap f _ {\phi_1}(r) \cap f _ {\phi_2}(s)\\}
$$
$$
f _ \theta(t \cup s)=f _ {\theta_1}(t,s) \cap f _ {\theta_2}(t) \cap f _ {\theta_3}(s)
$$
$$
f _ {\theta_1}(t,s)=f _ \phi(t,s)
$$
$$
f _ {\theta_2}(t)=f _ {\phi_1}(t)
$$
$$
f _ {\theta_3}(s)=f _ {\phi_2}(s)
$$
$$
R \bowtie _ \theta S=\sigma _ \phi(\sigma _ {\phi_1}(R) \times \sigma _ {\phi_2}(S))
$$