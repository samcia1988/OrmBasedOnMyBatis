#Theta ORM(TORM)---基于MyBatis实现及JPA定义的适应企业快速生产轻量级ORM扩展

author : 陈望旭

email : ranger.ying@gmail.com

organization : Theta Group@NJU

----

##绪论

###研究背景与动机
　　数据库是所有商业应用系统的核心所在，数据访问层的开发在系统开发中的重要性也不言而喻。由于几乎现在所有的生产中都采用面向对象语言，ORM（对象关系映射）就显得非常重要。ORM并不仅仅提高了生产效率，较低了开发成本，同时也在保证了应用数据及数据操作与实际数据库数据及数据操作的一致性的基础上，将双方解耦。

　　由于关系型数据库已经发展得非常成熟，相关的数据访问层框架也非常丰富全面，通过针对各自系统的具体分析，完全可以轻易找出符合开发需要的ORM框架。很多优秀的ORM框架在映射上做了非常完备的处理，以满足传统关系型数据库的需要。但是在当前企业级开发过程的数据库设计中，有着与传统关系型数据库设计迥然不同的特点，导致“完备”有时候反而成为了缺点。学术上，虽然满足1NF就是关系型数据库了，但一般讨论到数据库设计，都会要求其达到3NF甚至是BCNF。实际生产中，由于考虑到访问效率、数据迁移和开发维护成本等方面的因素，往往会对所有的关系（表）加入逻辑主键以满足2NF；同时，在非核心数据的设计上会使用大量的冗余，即使是在多关系的数据模型中，也往往会使用非物理形式外键形式（仅仅以属性来做关联标识）。这也就意味着，企业级的数据库设计其实绝大部分情况下是不满足也不需要满足3NF的，而是一种在2NF基础上的松散关联设计。

　　与此同时在企业级的应用开发中往往存在这样的情况：95%以上的数据库访问可能只是简单的增删改查，余下的5%却是核心业务逻辑中比较复杂的数据处理过程。面对这种情况，一套完整的ORM方案就更显得有些臃肿了。为此，我们需要的是一种既能满足快速开发、简单操作无配置化，又能满足复杂操作可充分灵活定制的数据访问层框架，这也就是本文即将展开的内容。

###研究目的与意义
　　因为Java是目前世界上使用最为广泛地面向对象语言，所以本文将以Java为例来探讨、解决研究背景中所讨论的问题。
　　
####现有解决方法
　　在目前使用Java语言的数据库访问层框架中大致分为两类：

* 以动态SQL为方向，如[MyBatis](http://mybatis.github.io/)。这一类框架支持普通SQL操作，大部分在执行前还会进行必要的优化、连接控制等，像MyBatis这类业界比较优秀的同时还能进行默认或自定义的POJO(Plain Old Java Objects的映射)。但由于其本质还是动态SQL框架，所以并没有直接实现SQL本身的封装，开发者需要对SQL进行直接或者以模板为基础的定义；
* 以完整的ORM为方向，如[Hibernate](http://www.hibernate.org/)。这一类框架则按照一些预定义的映射规则接口集合（如JPA）进行关系的属性与操作映射，当定义了DMO（数据模型对象）之后，在相应资源中定义数据库关联的具体映射规则，就可以使用DMO进行数据访问，并不需要再另外编写SQL。但是当其面对复杂的数据操作过程时，由于关系结构与对象结构本质上的不一致，往往会导致操作性能急剧下降。如果开发人员对此类情况经验不足或设计有所疏漏，实际应用中得数据模型与数据库中的数据模型不一致就变得很难避免且难以发现，大大增加了开发和维护的成本。

####现有问题分析和优化可能
　　如上文所述，一个矛盾产生了：

* 如果我使用动态SQL向框架，针对那简单的大多数场景，为了实现数据操作，我们要对应用中定义的DMO编写动态SQL生成实例，而这些实例在应用中生成出来的具体SQL却是大量类似的基础SQL，它们数量庞大、难以维护；
* 如果我们使用ORM向框架，针对那复杂的较少数，我们很难让数据库最终执行高效（而且大量的事实告诉我们很多时候这不仅不高效甚至不正确）的操作，虽然有些ORM框架，如Hibernate，也集成了部分动态SQL功能，但并不是特别理想，无法和传统的动态SQL向框架相比。　　

　　所以目前摆在我们面前是事实是，虽然我们在两方面都有成熟而强大的解决方案，但是面对实际生产的时候我们却不能仅仅通过选择来实现我们的全部需求。又由于已有的良好基础，我们解决问题的方案很容易得出，就是针对其中一种框架，添加另一类框架的功能子集以满足我们的需求，而对此我们选择也有两条：


* 基于Hibernate添加动态SQL支持。Hibernate自身带有其定义的HQL，但HQL只是语法类似SQL，本质上是基于面向对象进行设计的，所以必要路径还是在Hibernate的ORM上。那我们扩展的方式只有通过对Hibernate底层的调用执行SQL，比如数据库会话或数据库连接。但这样我们除了SQL操作本身的封装外，还需要重新定义POJO的映射规则，并且无法利用到Hibernate本身的优化机制；
* 基于MyBatis添加ORM支持。由于MyBatis本身支持POJO的高级映射，所以从核心层面上讲我们需要的只是将SQL操作封装成对象操作，相比对Hibernate的扩展复杂度和成本都大大降低了。而且对MyBatis的扩展是添加ORM部分，而完成映射之后，再进行实际数据访问都可以直接通过MyBatis已有的SQL加载和执行机制，在性能和安全性上都不需要额外的开销。

　　由此可见，基于MyBatis添加ORM支持是目前可见的最为理想的解决方案。

####需要解决的问题与挑战
　　确定了研究方向之后，也并不是就可以直接展开对MyBatis的扩展工作，由于MyBatis本身没有ORM功能，而上文中我们也简述了企业开发中数据访问层的特殊性，所以我们要做的不仅是实现，更包含了关系运算子集的定制、对定制子集的适用性证明以及为一些不属于关系代数范畴的数据库特性定制扩展的预留设计。按照研究进行的步骤，有一些核心的问题需要我们去解答：

* 如何定义满足企业需求的关系运算子集？
* 如何证明该集合在本文指定条件下与传统数据操作包含的关系运算集合等价？
* 如何在数据访问层定义满足上述关系运算子集的ORM映射规则？
* 如何设计并实现将POJO映射为为封装SQL操作提供传参的关系对象？
* 如何在不过大的影响Mybatis原有性能的前提下加入ORM层封装？
* 如何使这种改造具有较好的扩展性以便解决以后可能需要处理的特殊情况？

###研究的应用背景
JPA简介并描述对该研究的价值（直接使用?推翻重来？或是部分使用？）
MyBatis简介并描述对该研究的价值
###论文结构
关系运算子集定义
ORM定义
ORM实现（MyBatis）
ORM功能扩展性提供

##正文
###关系运算子集定义
####基础关系运算介绍
####一元关系运算（单表）集合定义
投影
选择
重命名
####多元关系运算分析及在该场景下的处理方式
#####多元运算的应用场景分析
笛卡尔积（着重分析）
并差集（简单分析，舍弃）
#####一次多元运算和多次一元运算的等价关系
#####多元运算和与其等价的一元运算的实际时空复杂度分析
#####是否将多元运算加入集合的分析
基础集合不加入多元运算
简单多元运算预留扩展并设计扩展模式
#####小结
###ORM定义
####JPA定义简介
####属性映射定义
关系属性
对象属性
表属性
####操作映射定义
关系运算
SQL
对象操作
####小结

###ORM实现
####数据模型对象相关
数据模型对象定义
关系对象定义
对象解析（数据模型对象->关系对象）
####MyBatis
#####MyBatis简介
#####MyBatis动态SQL的定义形式分析（采用接口形式）
XML形式（功能全面，不利于动态加载）
接口形式（功能不完整，动态加载较方便）
	纯接口（基于注解，不灵活）
	接口+SqlProvider（结构稍复杂，灵活）
#####动态SQL定义的生成与加载
#####定义的生成（源码级别）
接口定义
SqlProvider类定义
Sql模板定义
#####定义的加载
MyBatis懒加载
#####定义的执行
MyBatis一般执行形式
####小结

###ORM功能扩展性提供
不同层次的扩展性分析
####TORM源码扩展
#####数据对象解析扩展
注解扩展
数据模型对象读、写、初始化扩展
关系对象初始化扩展
#####MyBatis动态SQL接口扩展
模板扩展
SqlProvider扩展
接口方法扩展（不需要）
#####比较重要的待扩展项
适应常用复杂度的JOIN操作定义扩展
####MyBatis插件扩展
#####MyBatis插件对TORM执行的兼容性分析
#####已有扩展的设计与描述
数据库方言
数据字段加解密
分页查询
#####比较重要的待扩展项
其他非逻辑定语的扩展
####暂时不确定的扩展
批量处理的扩展形式思考

##结论
###目前研究成果及意义
####MyBatis的ORM改造实现
基础单表功能的实现
可扩展性的提供
对企业级应用的价值
###未来继续完善的方向
不增加开发复杂度下的联查扩展
非逻辑定语相关功能的完善
动态Sql模板的优化或重构
批量操作的扩展
更多可移植性功能的切面方式分析